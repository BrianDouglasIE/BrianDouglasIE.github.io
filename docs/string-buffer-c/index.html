<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>

    <!-- Meta Description -->
    <meta name="description" content="Making a StringBuffer in C"/>

    <!-- Keywords -->
    <meta name="keywords" content="Brian Douglas, blog, c"/>

    <!-- Author -->
    <meta name="author" content="Brian Douglas"/>

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website"/>
    <meta property="og:title" content="BrianDouglas.ie - Making a StringBuffer in C"/>
    <meta property="og:description" content="Making a StringBuffer in C"/>
    <meta property="og:url" content="https://www.briandouglas.ie"/>
    <meta property="og:image" content="http://www.briandouglas.ie/images/og-images/string-buffer-c.png"/>
    <meta property="og:image:type" content="image/png"/>
    <meta property="og:image:width" content="1280"/>
    <meta property="og:image:height" content="640"/>
    <meta property="og:site_name" content="BrianDouglas.ie"/>
    <meta property="og:image:alt" content="A preview image for the post titled 'Making a StringBuffer in C'"/>

    <!-- Twitter Meta -->
    <meta name="twitter:card" content="summary_large_image"/>
    <meta name="twitter:site" content="@BrianDouglasIE"/>
    <meta name="twitter:title" content="BrianDouglas.ie - Making a StringBuffer in C"/>
    <meta name="twitter:description" content="Making a StringBuffer in C"/>
    <meta name="twitter:image" content="http://www.briandouglas.ie/images/og-images/string-buffer-c.png"/>

    <!-- Canonical URL -->
    <link rel="canonical" href="https://www.briandouglas.ie"/>

    <!-- Favicon (Optional) -->
    <link rel="icon" href="https://www.briandouglas.ie/favicon.ico" type="image/x-icon"/>

    <!-- Robots -->
    <meta name="robots" content="index, follow"/>

    <!-- Favicon-->
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/>
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/>
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/>
    <link rel="manifest" href="/site.webmanifest"/>

    <title>Making a StringBuffer in C</title>
    <link rel="stylesheet" href="/styles.css">
</head>
<body>

<div class="content">
    <header class="site-header">
    <a href="/" class="home">Brian Douglas</a>

    <a href="https://github.com/BrianDouglasIE" class="github">
        <svg
                height="32"
                aria-hidden="true"
                viewBox="0 0 24 24"
                width="32"
                data-view-component="true"
        >
            <path
                    d="M12.5.75C6.146.75 1 5.896 1 12.25c0 5.089 3.292 9.387 7.863 10.91.575.101.79-.244.79-.546 0-.273-.014-1.178-.014-2.142-2.889.532-3.636-.704-3.866-1.35-.13-.331-.69-1.352-1.18-1.625-.402-.216-.977-.748-.014-.762.906-.014 1.553.834 1.769 1.179 1.035 1.74 2.688 1.25 3.349.948.1-.747.402-1.25.733-1.538-2.559-.287-5.232-1.279-5.232-5.678 0-1.25.445-2.285 1.178-3.09-.115-.288-.517-1.467.115-3.048 0 0 .963-.302 3.163 1.179.92-.259 1.897-.388 2.875-.388.977 0 1.955.13 2.875.388 2.2-1.495 3.162-1.179 3.162-1.179.633 1.581.23 2.76.115 3.048.733.805 1.179 1.825 1.179 3.09 0 4.413-2.688 5.39-5.247 5.678.417.36.776 1.05.776 2.128 0 1.538-.014 2.774-.014 3.162 0 .302.216.662.79.547C20.709 21.637 24 17.324 24 12.25 24 5.896 18.854.75 12.5.75Z"
            ></path>
        </svg>
    </a>
</header>
    <div class="breadcrumbs">
        <a href="/">Home</a> / <span>Making a StringBuffer in C</span>
    </div>

    <main>
        <article class="post">
            <header>
                <h1>Making a StringBuffer in C</h1>
                <time datetime="15/07/2025">July 15th, 2025</time>
            </header>

            <div class="body">
                <p>I've been writing a lot of C. Whilst doing so I have been questioning my sanity.
Am I an awful programmer? You know what, I think I might be.</p>
<p>Kudos to all those devs that created monumental feats with C. Because it is not
an easy tool to use. That said, I do enjoy writing C, just as long as I don't
have a deadline or any business critical software to deliver. But when I say enjoy, I mean
enjoyment in the sense of using a sycthe to cut a lawn, whilst my lawnmower watches on.
It's lovely using the sycthe, but at the end of the day when I am exhausted and cut
only a quarter of the grass that I could have cut with a mower in half the time, I do feel
a great sense of achievement. I'm exhausted and broken, but happy.</p>
<!-- more -->
<h2 id="stringbuffer">StringBuffer</h2>
<p>Anyway here is a string buffer implementation that I extracted from my project. You can see
the up to date source code at <a href="https://github.com/BrianDouglasIE/c_string_buffer">BrianDouglasIE/c<em>string</em>buffer</a>.</p>
<p>The replace and remove were particularly tricky to implement. My brain was on fire trying to figure out
how to juggle the memory about correctly.</p>
<h3 id="header">Header</h3>
<pre><code class="c language-c">#ifndef STRING_BUFFER_H
#define STRING_BUFFER_H

#include &lt;stddef.h&gt;

/// @brief A dynamic string buffer that supports common string operations.
typedef struct {
  size_t size;     ///&lt; The current size (length) of the string.
  size_t capacity; ///&lt; The total allocated capacity of the buffer.
  char *data;      ///&lt; Pointer to the character data.
} StringBuffer;

/// @brief Represents all positions where a match was found.
typedef struct {
  size_t *positions; ///&lt; Array of match positions.
  size_t count;      ///&lt; Number of matches found.
} MatchResult;

/// @brief Represents the result of splitting a string.
typedef struct {
  char **parts; ///&lt; Array of substrings resulting from the split.
  size_t count; ///&lt; Number of parts.
} SplitResult;

// Lifecycle

/// @brief Initializes a new, empty StringBuffer.
/// @return A pointer to the newly allocated StringBuffer.
StringBuffer *StringBuffer_init();

/// @brief Frees memory used by the given StringBuffer.
/// @param buf Pointer to the StringBuffer to be freed.
void StringBuffer_free(StringBuffer *buf);

/// @brief Clears the contents of the StringBuffer without freeing the object.
/// @param buf Pointer to the StringBuffer to be cleared.
void StringBuffer_clear(StringBuffer *buf);

// Operations

/// @brief Prints the contents of the StringBuffer to stdout.
/// @param buf Pointer to the StringBuffer to be printed.
void StringBuffer_print(const StringBuffer *buf);

/// @brief Appends text to the end of the StringBuffer.
/// @param buf Pointer to the StringBuffer.
/// @param text Null-terminated string to append.
void StringBuffer_append(StringBuffer *buf, const char *text);

/// @brief Prepends text to the beginning of the StringBuffer.
/// @param buf Pointer to the StringBuffer.
/// @param text Null-terminated string to prepend.
void StringBuffer_prepend(StringBuffer *buf, const char *text);

/// @brief Removes the first occurrence of text from the buffer starting from a given index.
/// @param buf Pointer to the StringBuffer.
/// @param text Null-terminated string to remove.
/// @param from Index to start the search from.
void StringBuffer_remove(StringBuffer *buf, const char *text, size_t from);

/// @brief Replaces the first occurrence of a substring with another string, starting from a given index.
/// @param buf Pointer to the StringBuffer.
/// @param original Substring to be replaced.
/// @param update Replacement string.
/// @param from Index to start the search from.
void StringBuffer_replace(StringBuffer *buf, const char *original,
                          const char *update, size_t from);

// Search &amp; Split

/// @brief Finds the index of the first occurrence of text starting from a given index.
/// @param buf Pointer to the StringBuffer.
/// @param text Substring to search for.
/// @param from Index to start the search from.
/// @return The index of the first occurrence, or -1 if not found.
int StringBuffer_index_of(const StringBuffer *buf, const char *text,
                          size_t from);

/// @brief Finds all occurrences of a substring starting from a given index.
/// @param buf Pointer to the StringBuffer.
/// @param text Substring to match.
/// @param from Index to start the search from.
/// @return A pointer to a MatchResult containing all match positions.
MatchResult *StringBuffer_match_all(const StringBuffer *buf, const char *text,
                                    size_t from);

/// @brief Splits the buffer into parts using the given delimiter.
/// @param buf Pointer to the StringBuffer.
/// @param delimiter String delimiter to split by.
/// @return A pointer to a SplitResult containing the parts.
SplitResult *StringBuffer_split(const StringBuffer *buf, const char *delimiter);

// Cleanup

/// @brief Frees the memory used by a MatchResult.
/// @param matches Pointer to the MatchResult to free.
void MatchResult_free(MatchResult *matches);

/// @brief Frees the memory used by a SplitResult.
/// @param split Pointer to the SplitResult to free.
void SplitResult_free(SplitResult *split);

#endif
</code></pre>
<h2 id="implementation">Implementation</h2>
<pre><code class="c language-c">#include "string_buffer.h"

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#define INITIAL_CAPACITY 16

static int ensure_capacity(StringBuffer *buf, size_t required) {
  if (required &lt;= buf-&gt;capacity)
    return 1;

  size_t new_capacity = buf-&gt;capacity ? buf-&gt;capacity : INITIAL_CAPACITY;
  while (new_capacity &lt; required) {
    new_capacity *= 2;
  }

  char *new_data = realloc(buf-&gt;data, new_capacity);
  if (!new_data) {
    perror("realloc");
    return 0;
  }

  buf-&gt;data = new_data;
  buf-&gt;capacity = new_capacity;
  return 1;
}

StringBuffer *StringBuffer_init() {
  StringBuffer *buf = malloc(sizeof(StringBuffer));
  if (!buf) {
    perror("malloc");
    return NULL;
  }

  buf-&gt;size = 0;
  buf-&gt;capacity = 0;
  buf-&gt;data = NULL;
  return buf;
}

void StringBuffer_free(StringBuffer *buf) {
  if (!buf)
    return;
  free(buf-&gt;data);
  free(buf);
}

void StringBuffer_clear(StringBuffer *buf) {
  if (!buf || !buf-&gt;data)
    return;
  buf-&gt;data[0] = '\0';
  buf-&gt;size = 0;
}

void StringBuffer_print(const StringBuffer *buf) {
  if (!buf || !buf-&gt;data)
    return;
  printf("size: %zu\n", buf-&gt;size);
  printf("data: %s\n", buf-&gt;data);
}

void StringBuffer_append(StringBuffer *buf, const char *text) {
  if (!buf || !text)
    return;

  size_t text_len = strlen(text);
  if (!ensure_capacity(buf, buf-&gt;size + text_len + 1))
    return;

  memcpy(buf-&gt;data + buf-&gt;size, text, text_len + 1);
  buf-&gt;size += text_len;
}

void StringBuffer_prepend(StringBuffer *buf, const char *text) {
  if (!buf || !text)
    return;

  size_t text_len = strlen(text);
  if (!ensure_capacity(buf, buf-&gt;size + text_len + 1))
    return;

  memmove(buf-&gt;data + text_len, buf-&gt;data,
          buf-&gt;size + 1);
  memcpy(buf-&gt;data, text, text_len);
  buf-&gt;size += text_len;
}

int StringBuffer_index_of(const StringBuffer *buf, const char *text,
                          size_t from) {
  if (!buf || !text || !buf-&gt;data || from &gt;= buf-&gt;size)
    return -1;

  char *match = strstr(buf-&gt;data + from, text);
  return match ? (int)(match - buf-&gt;data) : -1;
}

MatchResult *StringBuffer_match_all(const StringBuffer *buf, const char *text,
                                    size_t from) {
  if (!buf || !text || !buf-&gt;data || from &gt;= buf-&gt;size)
    return NULL;

  MatchResult *matches = malloc(sizeof(MatchResult));
  if (!matches)
    return NULL;
  matches-&gt;positions = NULL;
  matches-&gt;count = 0;

  int index = StringBuffer_index_of(buf, text, from);
  while (index != -1) {
    size_t *new_positions =
        realloc(matches-&gt;positions, sizeof(size_t) * (matches-&gt;count + 1));
    if (!new_positions) {
      MatchResult_free(matches);
      return NULL;
    }

    matches-&gt;positions = new_positions;
    matches-&gt;positions[matches-&gt;count++] = index;
    index = StringBuffer_index_of(buf, text, index + 1);
  }

  return matches;
}

void StringBuffer_remove(StringBuffer *buf, const char *text, size_t from) {
  if (!buf || !text || !buf-&gt;data || from &gt;= buf-&gt;size)
    return;

  size_t text_len = strlen(text);
  int index = StringBuffer_index_of(buf, text, from);

  while (index != -1) {
    size_t tail_len = buf-&gt;size - (index + text_len);
    memmove(buf-&gt;data + index, buf-&gt;data + index + text_len, tail_len + 1);
    buf-&gt;size -= text_len;
    index = StringBuffer_index_of(buf, text, index);
  }
}

void StringBuffer_replace(StringBuffer *buf, const char *original,
                          const char *update, size_t from) {
  if (!buf || !original || !update || !buf-&gt;data || from &gt;= buf-&gt;size)
    return;

  size_t original_len = strlen(original);
  size_t update_len = strlen(update);
  if (original_len == 0 || update_len == (size_t)-1)
    return;

  int index = StringBuffer_index_of(buf, original, from);

  while (index != -1) {
    if (update_len &gt; original_len) {
      if (!ensure_capacity(buf, buf-&gt;size + (update_len - original_len) + 1))
        return;
    }

    size_t tail_len = buf-&gt;size - (index + original_len);
    memmove(buf-&gt;data + index + update_len, buf-&gt;data + index + original_len,
            tail_len + 1);
    memcpy(buf-&gt;data + index, update, update_len);
    buf-&gt;size = buf-&gt;size - original_len + update_len;

    index = StringBuffer_index_of(buf, original, index + update_len);
  }
}

SplitResult *StringBuffer_split(const StringBuffer *buf,
                                const char *delimiter) {
  if (!buf || !delimiter || !buf-&gt;data)
    return NULL;

  char *copy = strdup(buf-&gt;data);
  if (!copy)
    return NULL;

  SplitResult *result = malloc(sizeof(SplitResult));
  if (!result) {
    free(copy);
    return NULL;
  }

  result-&gt;parts = NULL;
  result-&gt;count = 0;

  char *token = strtok(copy, delimiter);
  while (token) {
    char **tmp = realloc(result-&gt;parts, sizeof(char *) * (result-&gt;count + 1));
    if (!tmp) {
      SplitResult_free(result);
      free(copy);
      return NULL;
    }
    result-&gt;parts = tmp;
    result-&gt;parts[result-&gt;count] = strdup(token);
    if (!result-&gt;parts[result-&gt;count]) {
      SplitResult_free(result);
      free(copy);
      return NULL;
    }
    result-&gt;count++;
    token = strtok(NULL, delimiter);
  }

  free(copy);
  return result;
}

void MatchResult_free(MatchResult *matches) {
  if (!matches)
    return;
  free(matches-&gt;positions);
  free(matches);
}

void SplitResult_free(SplitResult *split) {
  if (!split)
    return;
  for (size_t i = 0; i &lt; split-&gt;count; i++) {
    free(split-&gt;parts[i]);
  }
  free(split-&gt;parts);
  free(split);
}
</code></pre>
<h2 id="tests">Tests</h2>
<pre><code class="c language-c">#include "string_buffer.h"

#include &lt;assert.h&gt;
#include &lt;string.h&gt;

int main(void) {
  StringBuffer *buf = StringBuffer_init();
  assert(buf != NULL);

  StringBuffer_append(buf, "hello");
  assert(buf-&gt;size == 5);
  assert(strcmp(buf-&gt;data, "hello") == 0);

  StringBuffer_append(buf, " world");
  assert(buf-&gt;size == 11);
  assert(strcmp(buf-&gt;data, "hello world") == 0);

  assert(StringBuffer_index_of(buf, "hello", 0) == 0);
  assert(StringBuffer_index_of(buf, "world", 0) == 6);
  assert(StringBuffer_index_of(buf, "mars", 0) == -1);
  assert(StringBuffer_index_of(buf, "llo", 2) == 2);
  assert(StringBuffer_index_of(buf, "hello", 99) == -1);
  assert(StringBuffer_index_of(buf, "hello", buf-&gt;size) == -1);
  assert(StringBuffer_index_of(buf, "d", buf-&gt;size - 1) ==
         (int)(buf-&gt;size - 1));
  assert(StringBuffer_index_of(buf, "h", 1) == -1);

  MatchResult *mr = StringBuffer_match_all(buf, "l", 0);
  if (!mr) {
    return -1;
  }
  assert(mr-&gt;count == 3);
  assert(mr-&gt;positions[0] == 2);
  assert(mr-&gt;positions[1] == 3);
  assert(mr-&gt;positions[2] == 9);
  MatchResult_free(mr);

  SplitResult *sr = StringBuffer_split(buf, " ");
  assert(sr-&gt;count == 2);
  assert(strcmp(sr-&gt;parts[0], "hello") == 0);
  assert(strcmp(sr-&gt;parts[1], "world") == 0);
  SplitResult_free(sr);

  StringBuffer_prepend(buf, "hello ");
  assert(buf-&gt;size == 17);
  assert(strcmp("hello hello world", buf-&gt;data) == 0);

  StringBuffer_remove(buf, " ", 0);
  assert(buf-&gt;size == 15);
  assert(strcmp("hellohelloworld", buf-&gt;data) == 0);

  StringBuffer *remove_overlap_test = StringBuffer_init();
  StringBuffer_append(remove_overlap_test, "lalalalala");
  StringBuffer_remove(remove_overlap_test, "ala", 0);
  assert(strcmp(remove_overlap_test-&gt;data, "llla") == 0);
  assert(remove_overlap_test-&gt;size == 4);
  StringBuffer_free(remove_overlap_test);

  StringBuffer_replace(buf, "hellohello", "hello ", 0);
  assert(buf-&gt;size == 11);
  assert(strcmp("hello world", buf-&gt;data) == 0);

  StringBuffer *replace_overlap_test = StringBuffer_init();
  StringBuffer_append(replace_overlap_test, "lalalalala");
  StringBuffer_replace(replace_overlap_test, "ala", "", 0);
  assert(strcmp(replace_overlap_test-&gt;data, "llla") == 0);
  assert(replace_overlap_test-&gt;size == 4);
  StringBuffer_free(replace_overlap_test);

  StringBuffer_clear(buf);
  assert(buf-&gt;size == 0);
  assert(strlen(buf-&gt;data) == 0);

  StringBuffer_free(buf);
  return 0;
}
</code></pre>
            </div>

            <footer>
                <p><i>Until next time,</i></p>
                <p><i>Brian</i></p>
            </footer>
        </article>
    </main>

    <footer class="site-footer">
    <p>
        <small>Since August 4th, 2023. All words by Brian
            Douglas. <a href="mailto:brianwdouglas@proton.me">Have a comment?</a></small>
    </p>
</footer>

</div>

<script src="/scripts/chicken-and-magpie.js"></script>
<script src="/scripts/skip-to-section.js"></script>
<script src="/scripts/code-highlighter.js"></script>
</body>
</html>
