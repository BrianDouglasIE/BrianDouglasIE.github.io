<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8"/>    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>    <!-- Meta Description -->    <meta name="description" content="One assertion per test please"/>    <!-- Keywords -->    <meta name="keywords" content="Brian Douglas, blog, "/>    <!-- Author -->    <meta name="author" content="Brian Douglas"/>    <!-- Open Graph / Facebook -->    <meta property="og:type" content="website"/>    <meta property="og:title" content="BrianDouglas.ie - One assertion per test please"/>    <meta property="og:description" content="One assertion per test please"/>    <meta property="og:url" content="https://www.briandouglas.ie"/>    <meta property="og:image:type" content="image/png"/>    <meta property="og:image:width" content="1280"/>    <meta property="og:image:height" content="640"/>    <meta property="og:site_name" content="BrianDouglas.ie"/>    <meta property="og:image:alt" content="A preview image for the post titled 'One assertion per test please'"/>    <!-- Twitter Meta -->    <meta name="twitter:card" content="summary_large_image"/>    <meta name="twitter:site" content="@BrianDouglasIE"/>    <meta name="twitter:title" content="BrianDouglas.ie - One assertion per test please"/>    <meta name="twitter:description" content="One assertion per test please"/>    <!-- Canonical URL -->    <link rel="canonical" href="https://www.briandouglas.ie"/>    <!-- Favicon (Optional) -->    <link rel="icon" href="https://www.briandouglas.ie/favicon.ico" type="image/x-icon"/>    <!-- Robots -->    <meta name="robots" content="index, follow"/>    <!-- Favicon-->    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/>    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/>    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/>    <link rel="manifest" href="/site.webmanifest"/>    <title>One assertion per test please</title>    <link rel="stylesheet" href="/styles.css"></head><body><div class="content">    <header class="site-header">    <a href="/" class="home">Brian Douglas</a>    <a href="https://github.com/BrianDouglasIE" class="github">        <svg                height="32"                aria-hidden="true"                viewBox="0 0 24 24"                width="32"                data-view-component="true"        >            <path                    d="M12.5.75C6.146.75 1 5.896 1 12.25c0 5.089 3.292 9.387 7.863 10.91.575.101.79-.244.79-.546 0-.273-.014-1.178-.014-2.142-2.889.532-3.636-.704-3.866-1.35-.13-.331-.69-1.352-1.18-1.625-.402-.216-.977-.748-.014-.762.906-.014 1.553.834 1.769 1.179 1.035 1.74 2.688 1.25 3.349.948.1-.747.402-1.25.733-1.538-2.559-.287-5.232-1.279-5.232-5.678 0-1.25.445-2.285 1.178-3.09-.115-.288-.517-1.467.115-3.048 0 0 .963-.302 3.163 1.179.92-.259 1.897-.388 2.875-.388.977 0 1.955.13 2.875.388 2.2-1.495 3.162-1.179 3.162-1.179.633 1.581.23 2.76.115 3.048.733.805 1.179 1.825 1.179 3.09 0 4.413-2.688 5.39-5.247 5.678.417.36.776 1.05.776 2.128 0 1.538-.014 2.774-.014 3.162 0 .302.216.662.79.547C20.709 21.637 24 17.324 24 12.25 24 5.896 18.854.75 12.5.75Z"            ></path>        </svg>    </a></header>    <div class="breadcrumbs">        <a href="/">Home</a> / <span>One assertion per test please</span>    </div>    <main>        <article class="post">            <header>                <h1>One assertion per test please</h1>                <time datetime="17/08/2024">17/08/2024</time>            </header>            <div class="body">                <p>Please! when you are writing tests try to limit each test case to one <code>expect</code>.
Let's refactor the monstrosity below to understand why fewer expects and more
tests are better.</p>
<magpie-trinket>
Try your best to write test cases as if they were telling a story.
Stick to one assertion per test, and split out any shared logic into
hooks, like <code>beforeEach</code> and <code>beforeAll</code>.
</magpie-trinket>
<h2>The Monstrosity</h2>
<pre><code class="language-javascript">import { render, screen, fireEvent } from '@testing-library/react';
import { expect, test } from 'vitest';
import MyComponent from './MyComponent';

test('User Name Submit Form', () =&gt; {
  const mockApiData = { user: 'John Doe' };
  const apiFetchMock = vi.fn(() =&gt; Promise.resolve(mockApiData));

  render(&lt;MyComponent fetchData={apiFetchMock} /&gt;);

  const header = screen.getByText(/My Dashboard/i);
  expect(header).toBeInTheDocument();

  const button = screen.getByRole('button', { name: /Submit/i });
  expect(button).toBeInTheDocument();
  expect(button).toBeDisabled();

  const input = screen.getByPlaceholderText('Enter your name');
  expect(input).toBeInTheDocument();
  expect(input.value).toBe('');

  fireEvent.change(input, { target: { value: 'John Doe' } });
  expect(input.value).toBe('John Doe');

  expect(button).not.toBeDisabled();

  fireEvent.click(button);

  const successMessage = screen.getByText(/Success!/i);
  expect(successMessage).toBeInTheDocument();
});
</code></pre>
<p>Now you wouldn't know it at first glance but the above test case is used to validate
a form where the user can submit their name. The test technically works, but it does
not communicate it's intent.</p>
<p>I see code like this all the time. Especially when working with UI frameworks like
React, Angular, and Vue. Developers pile assertion upon assertion into one large
test case. And when a new requirement comes along? they just add in yet another
assertion.</p>
<p>Why? because the set-up is <em>done</em>, and bulky, and they don't want to have to rewrite
or duplicate the work.</p>
<chicken-asks>
So how do we fix this?
</chicken-asks>
<magpie-replies>
We break out each assertion into its own test.
</magpie-replies>
<h2>The Refactor</h2>
<pre><code class="language-javascript">import { render, screen, fireEvent } from '@testing-library/react';
import { beforeEach, expect, test } from 'vitest';
import MyComponent from './MyComponent';

describe('User Name Submit Form', () =&gt; {
    let apiFetchMock;

    beforeEach(() =&gt; {
        const mockApiData = { user: 'John Doe' };
        apiFetchMock = vi.fn(() =&gt; Promise.resolve(mockApiData));

        render(&lt;MyComponent fetchData={apiFetchMock} /&gt;);
    });

    test('renders header', () =&gt; {
        const header = screen.getByText(/My Dashboard/i);
        expect(header).toBeInTheDocument();
    });

    test('renders input field', () =&gt; {
        const input = screen.getByPlaceholderText('Enter your name');
        expect(input).toBeInTheDocument();
    });

    test('initial input field is empty', () =&gt; {
        const input = screen.getByPlaceholderText('Enter your name');
        expect(input.value).toBe('');
    });

    test('changes input value on user input', () =&gt; {
        const input = screen.getByPlaceholderText('Enter your name');
        fireEvent.change(input, { target: { value: 'John Doe' } });
        expect(input.value).toBe('John Doe');
    });

    test('renders submit button', () =&gt; {
        const button = screen.getByRole('button', { name: /Submit/i });
        expect(button).toBeInTheDocument();
    });

    test('submit button is disabled initially', () =&gt; {
        const button = screen.getByRole('button', { name: /Submit/i });
        expect(button).toBeDisabled();
    });

    test('submit button is enabled after input change', () =&gt; {
        const input = screen.getByPlaceholderText('Enter your name');
        fireEvent.change(input, { target: { value: 'John Doe' } });
        const button = screen.getByRole('button', { name: /Submit/i });
        expect(button).not.toBeDisabled();
    });
});

</code></pre>
<p>In the above refactor any shared test set up is broken out into a <code>beforeEach</code> hook
and each assertion is given its own test case.</p>
<p>The advantage of doing this becomes immediately clear. The tests now read like a
story. We know exactly what the intent of each test case is, and  we only have to
read a small amount of code to understand the test's logic. To accentuate my point
about read ability. If we were to take the name of each test case and list it out
we would have the following verse.</p>
<pre><code>User Name Submit Form
    renders header
    renders input field
    initial input field is empty
    changes input value on user input
    renders submit button
    submit button is disabled initially
    submit button is enabled after input change
</code></pre>
<p>This reads like a list of requirements. Which is essentially what UI tests are.
Compare this with the story the initial test gave us.</p>
<pre><code>User Name Submit Form
</code></pre>
<p>Yea, not as descriptive. Who knows what that test does. Not me.</p>
<p>So in summary, try your best to write your test cases as if they were telling a
story. Try to stick to one assertion per test, and split out any shared logic into
hooks, like <code>beforeEach</code> and <code>beforeAll</code>.</p>
            </div>            <footer>                <p><i>Until next time,</i></p>                <p><i>Brian</i></p>            </footer>        </article>    </main>    <footer class="site-footer">    <p>        <small>Since August 4th, 2023. All words by Brian            Douglas. <a href="mailto:brianwdouglas@proton.me">Have a comment?</a></small>    </p></footer></div><script src="/scripts/chicken-and-magpie.js"></script><script src="/scripts/skip-to-section.js"></script><script src="/scripts/code-highlighter.js"></script></body></html>